---
title: C语言的数组与指针
tags: C/C++
categories: Miscellaneous
toc: true
mathjax: true
abbrlink: 3898466922
date: 2021-07-19 00:00:00
---

曾经在初学C语言的时候，误以为指针和数组的本质是相同的，而且发现许多人都这么认为。后来对于计算机硬件和操作系统有了更深的了解，尤其是学了汇编和编译原理之后，对编程语言的深层的原理也更加熟悉，回过头来意识到，「C语言数组的本质是指针」这个命题是错误的。

# 数据类型的确定

要厘清刚才的问题，可能需要先明晰，C语言当中声明变量时，变量的类型是如何确定的。<!--more-->当然，对于简单的情况而言，比如`int a = 1`这样的，很显然，变量`a`的类型是`int`，但当声明变量的表达式更复杂的时候，比如`int (*p)[4]`这样的，要如何确定其类型呢？其实只需简单记住一句话：「C语言定义变量的类型，是由一个等式方程确定的」。

就以这个例子来看，这个方程是
$$
\mathrm{表达式(*p)[4]的类型 = int}
$$
如此一来，我们便可以如解方程一般，一层一层剥开，得到`p`的类型：
$$
\begin{align}
\mathrm{(*p)\left[4\right]的类型}& = \mathrm{int}\\
\mathrm{*p的类型}& = \mathrm{4个int类型变量组成的数组}\\
\mathrm{p的类型}& = \mathrm{指向由4个int类型变量所组成数组的指针}
\end{align}
$$
更复杂的表达式可以依此类推。

# 「残缺」的数组类型

关于数组与指针的困惑，可能部分要归因于C语言「残缺」的数组类型。根据前文所述，`int a[4]`这样一个表达式所定义的变量，是`a`，而`a`的类型，是由4个int类型变量组成的数组。数组这种数据类型上定义了哪些运算呢？相比于其他更简单的类型而言，那些简单的如`+`、`-`、`*`、`/`的运算符，都无法直接用于数组类型，而只能用于数组的元素，乃至于连赋值符号`=`都只能在声明并同时初始化的时候使用。用`int a[]`这样一个语句定义了数组`a`，然而这个标识符`a`，可以结合的运算符只有`&`，`sizeof()`、`alignof()`——除非它不被当作数组对待。的确，数组名是可以与加号结合的，比如`*(a + 1)`与`a[1]`是等价的，但此处的数组名并不再表示一整个数组对象，而是被隐式类型转换，成了指向数组第一个元素的指针，而且是右值。**剥离了隐式类型转换的障眼法，作为表示数组对象本身的数组名，只支持几种特定的运算。运算的「残缺」给隐式类型转换留下了空间，而数组名这样的双重身份，也容易使人误以为C语言数组就是指针。**

当然，这里的「残缺」并非说这是C语言的错误，或者设计者考虑欠周到，C语言这样的设计与C语言自身的特质是紧密相关的，有其历史背景。其实把变量名转换成地址，这一点很有汇编的风格，汇编中变量名实际都是表示地址，而这种数组的写法其实也与汇编类似，数组元素`a[1]`甚至可以写成`1[a]`，因为加法是可交换的。

# 赋值的等号

假如我们这样声明一个变量`int (*p)[4]`中新出现一个标识符`p`，它就是我们要定义的变量的名称，假如我们要在定义的同时初始化这个变量，写成类似`int (*p)[4] = 某表达式`的内容，中间的等号是赋值的意思，然而其作为等号的身份可能会给我们一种它是等式的暗示，然而究竟是谁的值等于等号右边的表达式，是我们新定义的变量`p`，还是`=`紧跟着的`(*p)[4]`呢？答案是前者，我们将等号右边的表达式赋值给我们新定义的变量`p`。

倘若我们分别定义一个一维数组和一个指针：

```c++
int a[] = {1, 3, 5, 7};
int *p = {1, 3, 5, 7};
```

第二个会出错，因为这个声明只申请了一个`int *`类型的内存空间，而不会去申请容纳一个数组的空间。倘若我们对`a`赋值，也会出错，因为`a`是被隐式转换成了一个右值。我想这个也足够说明，**数组名虽然可以被隐式转化为指向`int`类型对象的指针，但它本质还是一个数组，与指针不同。**

# 作为函数参数的数组

涉及到数组的隐式转换的还有作为函数的参数的时候。前文说过，数组不能直接被`=`赋值，除非是在声明的同时用`{}`括起来的列表来初始化（这种大括号并非是数组特有，不像有的编程语言是用括号来专门表示数组对象，并可以用于任意时候的赋值，C语言的这种列表则是用于初始化连续的内存空间，例如结构体对象也可以用这种列表初始化），而作为形参的数组，面临的正是被实参赋值的场景，所以会被隐式转换为指针变量。而且因为数组的地址空间由实参提供，所以也不需要再手动分配内存。如果形参是一维数组，会被转换为指向其元素类型的指针，如果是二维数组，会被转换为指向一维数组的指针，三维数组则被转换为指向二维数组的指针，依次类推。这里还有个容易陷入的误区，一维数组的数组名可以被隐式地转换为一级指针，但二维数组的数组名并不是被转换为二级指针（指向指针的指针），而是指向一维数组的一级指针（指向数组的指针），这也是一个体现数组与指针的区别之处。

# 其他

`int (*p)[]`与`int *p[]`有什么区别，如何记忆？首先说结论，前者所声明的`p`是指向数组的指针，后者所声明的`p`是存储指针变量的数组。

这里涉及到C语言运算符的结合方向、优先级，`*`是右结合的，`[`是左结合的，所以他们都是与`p`结合的，而`[`的优先级高于`*`。所以，如果不加小括号，`[]`就要比`*`更优先与`p`结合，判定其类型的过程就是：`*p[]`是整型，`p[]`是指向整型的指针，`p`是由指向整型的指针构成的数组；而对于`int (*p)[]`来说，`()`使`*`与`p`更优先结合，所以判定其类型的过程是：`(*p)[]`是整型，`*p`是整型元素的数组，`p`是指向整型元素数组的指针。